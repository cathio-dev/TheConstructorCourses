//-- 1.1 --//
  Welcome to the Intermediate ROS 2 course!

In this course, you will explore key concepts that improve execution, communication, and configuration in ROS 2, enabling you to develop more efficient and scalable robotic applications. You'll dive into topics such as launch files, node parameters, threading, callback management, Quality of Service (QoS), Data Distribution Service (DDS), and managed nodes, all of which are essential for optimizing real-world robotic systems.

By the end of this course, youâ€™ll be equipped to work with advanced ROS 2 functionalities, making your robotic solutions more robust and adaptable.

//-- 1.3 --//
  What I will learn:
    How to create different types of launch files in ROS 2
    Working with parameters to configure ROS 2 nodes
    Threading in ROS 2 for managing concurrent tasks
    Callback management for efficient message handling
    Understanding Quality of Service (QoS) and its impact on communication
    Exploring Data Distribution Service (DDS) in ROS 2
    Implementing and managing Managed Nodes in ROS 2

//-- 2.2 --//

  message_info = launch.actions.LogInfo(
        msg=str(rviz_config_dir))

...


return LaunchDescription(
        [
            ...,
            message_info
        ]
    )
LogInfo, allows you to post a message inside the ROS2 logging system from a launch file.

In this case, the message to be printed is the full path to the Rviz config file. This can be useful to check if we are loading the proper config file.

In order to print a message during launch time:

you create a LogInfo variable, with argument (msg='the string message you want to print').
then you provide that variable to the LaunchDescription.
===============================================================
name_of_launch_object = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(MY_LAUNCH_FILE_PATH)
        )
    )

name_of_launch_object_2 = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(MY_LAUNCH_FILE_PATH_2)
        )
    )
    
...


return LaunchDescription([
        name_of_launch_object,
        name_of_launch_object_2,

    ])

BASIC STRUCTURE:

#!/usr/bin/python3
# -*- coding: utf-8 -*-
import os

from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource

def generate_launch_description():

    pkg_box_bot_gazebo = get_package_share_directory('launch_tests_pkg')

    move_robot = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(pkg_box_bot_gazebo, 'launch',
                         'move.launch.py'),
        )
    )

    start_rviz = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(pkg_box_bot_gazebo, 'launch', 'start_rviz.launch.py'),
        )
    )

    return LaunchDescription([
        move_robot,
        start_rviz,

    ])

======================================================================================

//-- 2.3 --//
  Declaring args and printing in launch

  import launch
# These log actions are: https://github.com/ros2/launch/blob/master/launch/launch/actions 
# Logging, for example: https://github.com/ros2/launch/blob/master/launch/launch/actions/log_info.py

def generate_launch_description():
    return launch.LaunchDescription([
        launch.actions.DeclareLaunchArgument('extra_msg', default_value='hello world'),
        launch.actions.DeclareLaunchArgument('important_msg'),
        launch.actions.LogInfo(msg=launch.substitutions.LaunchConfiguration('extra_msg')),
        launch.actions.LogInfo(msg=launch.substitutions.LaunchConfiguration('important_msg')),
    ])

//-- 3.3 --//

//-- 4.1 --//

In ROS 2, parameters provide a way to configure and customize nodes at runtime, making your robots more flexible and adaptable to different environments and tasks. Parameters allow you to set values for variables that can affect the behavior of nodes without needing to modify the code itself. This makes it easier to adapt to changing conditions, tune robot behaviors, or adjust configurations across different systems.

In this unit, you will learn how to work with parameters in ROS 2, including how to define, set, get, and update parameters within your nodes. You will also explore the different types of parameters, their usage, and how they help you create more dynamic and reusable robotic applications.

By the end of this unit, you will be able to confidently work with parameters in ROS 2 to improve your robot's flexibility and performance.

//-- 4.4 --//
Parameters

auto param_desc = rcl_interfaces::msg::ParameterDescriptor{};
    param_desc.description = "Sets the velocity (in m/s) of the robot.";
    this->declare_parameter<std::double_t>("velocity", 0.0, param_desc);

after the command: ros2 param list:

/param_vel_node:
  qos_overrides./parameter_events.publisher.depth
  qos_overrides./parameter_events.publisher.durability
  qos_overrides./parameter_events.publisher.history
  qos_overrides./parameter_events.publisher.reliability
  use_sim_time
  velocity

----------------------------------------------------------------------

after ros2 param describe:

user:~/ros2_ws$ ros2 param describe /param_vel_node velocity
Parameter name: velocity
  Type: double
  Description: Sets the velocity (in m/s) of the robot.
  Constraints:

user:~/ros2_ws$ ros2 param
delete    describe  dump      get       list      load      set
user:~/ros2_ws$ ros2 param


//-- 4.9 --//

  basic launch structure:

  from launch import LaunchDescription
from launch_ros.actions import Node


def generate_launch_description():
    return LaunchDescription([
        Node(
            package='parameter_tests',
            executable='param_vel_node',
            name='param_vel_node',
            output='screen',
            emulate_tty=True,
            parameters=[
                {'velocity': 0.2}
            ]
        )
    ])

// Passa o parametro automaticamente

//-- 4.10 --//

PARAMETER IF

class VelParam : public rclcpp::Node {
public:
  rcl_interfaces::msg::SetParametersResult
  parametersCallback(const std::vector<rclcpp::Parameter> &parameters) {
    rcl_interfaces::msg::SetParametersResult result;
    result.successful = false;
    result.reason = "";
    for (const auto &parameter : parameters) {
      if (parameter.get_name() == "velocity" && parameter.as_double() > 0.2) {
        RCLCPP_INFO(this->get_logger(), "Parameter 'velocity' not changed!");
        result.reason = "Parameter 'velocity' cannot be higher than 0.2";
      } else {
        RCLCPP_INFO(this->get_logger(), "Parameter 'velocity' changed!");
        result.successful = true;
        result.reason = "Parameter 'velocity' is lower than 0.2";
      }
    }
    return result;
  }

// so conseguimos mandar o parametro se suprir a necessidade do IF, muito interessante.


//-- 5.1 --//

Introduction:

Modern robotics applications often require multiple tasks to run simultaneously, such as processing sensor data, executing motion planning, and communicating with other systems. This is where multi-threading becomes essential. Multi-threading allows different parts of a program to execute concurrently, improving performance and responsiveness.

In ROS 2, executors, callback groups, and WaitSet are key mechanisms for managing multi-threaded execution. The WaitSet allows you to wait for multiple events simultaneously, enabling more efficient handling of asynchronous tasks. By leveraging multi-threading, executors, callback groups, and WaitSet, you will enhance the efficiency and responsiveness of your ROS 2 applications, ensuring they can handle complex, real-time tasks effectively.

In this unit, you will learn how to combine all of these concepts to efficiently manage the execution of multiple ROS 2 nodes and callbacks, optimizing performance and responsiveness in your robotic applications.

LAUNCH GAZEBO: ros2 launch box_bot_gazebo main_simple.launch.xml

UNIT SETUP: cd ~/ros2_ws/src
ros2 pkg create --build-type ament_cmake executors_exercises_pkg --dependencies rclcpp
cd ~/ros2_ws
colcon build --symlink-install
source install/setup.bash

//-- 5.3 --//

#include <nav_msgs/msg/odometry.hpp>
#include <rclcpp/rclcpp.hpp>

class OdomSubscriber : public rclcpp::Node {
public:
  OdomSubscriber(std::string odom_topic_name) : Node("simple_subscriber") {

    subscription_ = this->create_subscription<nav_msgs::msg::Odometry>(
        odom_topic_name, 10,
        std::bind(&OdomSubscriber::topic_callback, this,
                  std::placeholders::_1));
  }

private:
  void topic_callback(const nav_msgs::msg::Odometry::SharedPtr msg) {
    RCLCPP_INFO(this->get_logger(), "Odometry=['%f','%f','%f']",
                msg->pose.pose.position.x, msg->pose.pose.position.y,
                msg->pose.pose.position.z);
  }
  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr subscription_;
};

int main(int argc, char *argv[]) {
  // Some initialization.
  rclcpp::init(argc, argv);

  // Instantiate a node.
  std::shared_ptr<OdomSubscriber> node =
      std::make_shared<OdomSubscriber>("/box_bot_1/odom");



  // This is the same as a print in ROS
  RCLCPP_INFO(node->get_logger(), "Bacon pancakes, makin bacon pancakes");

  // Start and spin executor SingleThreadded
  //   rclcpp::spin(node);

  // Same code, but in steps
  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(node);
  executor.spin();

  // Shut down and exit.
  rclcpp::shut down();
  return 0;
}

// Simple subscriber 
// Passa-se o tipo do odom como parametro

//-- 5.4 --//
The Multi-Threaded Executor: It creates a variable number of threads that allow multiple messages/events to process in parallel.

//-- 5.5 --//

Call back groups:

Reentrant: All the Callbacks in these types of groups will be able to be executed simultaneously. The Executor will generate as many threads as is needed to do so.
MutualyExclusive: All the Callbacks inside these types of groups, can be executed ONE at a time. This is useful for Callbacks that, for some reason, affect the same system or use the same resources as another one. In addition, it gives you better control over the Callback flow.

REENTRANT : WORK IN PARALLEL
callback_group_ =
        this->create_callback_group(rclcpp::CallbackGroupType::Reentrant);


Mutually Exclusive: BY DEFAULT THE CALL BACKS ARE ALL IN THE MUTUALLY
callback_group_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);

Multiple mutualyexclusive: Has the same behavior as REENTRANT, creates 2 threads.
callback_group_ = this->create_callback_group(
        rclcpp::CallbackGroupType::MutuallyExclusive);
callback_group_2 = this->create_callback_group(
    rclcpp::CallbackGroupType::MutuallyExclusive);



