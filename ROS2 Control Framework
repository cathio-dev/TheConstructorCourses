//-- 1.1 --//

Ros2 control

ROS 2 Control is a powerful framework for managing robotic hardware and controllers in ROS 2, enabling precise and flexible control of robots in both simulation and real-world applications. This course provides a structured approach to learning ros2_control, from setting up controllers to creating custom hardware interfaces and controllers.

//-- 1.2 --//

This is where the term control comes into play. Control means managing, commanding, or directing the behavior of a device, or a system of devices, to get expected results. A whole field of study called Control Theory is dedicated to studying and solving control problems.

//-- 2.2 --// START

//-- 2.3 --//

To add ros2_control to our robot we will go through the following steps:

Create a new package
Create a configuration file for the controller manager and the control algorithms
Update the robot's description xacro file
Create a launch file that will bring up the controllers
Test the robot controlled by ros2_control

//-- 2.4 --//

//-- 2.5 --//

Important: the joint names that you define in this configuration file must match the joint names in the URDF/XACRO file. The YAML file above for instance, assigns a joint with name "joint1" to both controllers. "joint1" corresponds to the joint name defined by the XML tag <joint name="joint1" type="continuous"> inside the .xacro file (more on that below!).

//-- 2.6 --//

Updating the xacrofile with the hardware interface and joint parameters

//-- 2.7 --//

Config ready, URDF updated, lets create a Launch File

    robot_state_pub_node = Node(
        package="robot_state_publisher",
        executable="robot_state_publisher",
        output="both",
        parameters=[robot_description],
    )

Here we generate a robot_state_publisher node providing the robot_description variable as parameter. This node listens to the /joint_states topic from the joint_state_broadcaster and provides an ongoing view of the robot joint locations through the tf and tf_static topics.

    joint_state_broadcaster_spawner = Node(
        package="controller_manager",
        executable="spawner",
        arguments=["joint_state_broadcaster",
                   "--controller-manager", "/controller_manager"],
    )

Here we leverage a python script called spawner, which is provided by the controller_manager package, in order to load and start the joint_state_broadcaster.
The joint_state_broadcaster publishes the state of the robot on the topics "/rrbot_controller/state" and "/joint_states". The robot state, described by the position, velocity and effort of every robot joint, is transmitted as an "sensor_msgs/ JointState" ROS2 message, that can be read by any ROS2 node.


//-- 2.9 --//

HANDS ON PRACTICE

// -- 3.2 -- //

Additionally, there are also 6 transition processes which are tasks executed during the transition from one state to another. Possible transition processes are:

on_configure
on_cleanup
on_activate
on_deactivate
on_shutdown
on_error

see the types: ros2 control list_controller_types
the current types: ros2 control list_controllers

ros2 control unload_controller (controller): da unload neles
ros2 control set_controller_state (controller) (estado: stop, start)

load_controller  faz load novamente

//-- 3.4 --//

//-- 3.5 --//

ros2 run controller_manager spawner my_controller_name --controller-type joint_state_broadcaster/JointStateBroadcaster

SPAWER 

//-- 4.0 --//

//-- 4.3 --//

Hardware interface:

To successfully integrate a hardware device with ros2_control, follow these key steps:

Create a package to contain your hardware interface implementation.
Write a header file defining the interface and necessary functions.
Implement the source file (.cpp) to handle communication with the hardware.
Configure CMakeLists.txt and package.xml to ensure proper compilation and integration.
Register the interface as a plugin so it can be recognized and used within ros2_control.
By following these steps, you will establish a functional hardware interface that connects your device to ROS 2.

//-- 4.4 --//

cd ~/ros2_ws/src

hardware_interface
pluginlib
rclcpp
rclcpp_lifecycle

//-- 4.20 --//

Create a config yaml

# Controller manager configuration
controller_manager:
  ros__parameters:
    update_rate: 10  # Hz

    ### Controllers to be initialized at startup ###
    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    forward_position_controller:
      type: forward_command_controller/ForwardCommandController

    position_trajectory_controller:
      type: joint_trajectory_controller/JointTrajectoryController


### Properties of the controllers that we will use and definition of joints to use ###
forward_position_controller:
  ros__parameters:
    joints:
      - joint1
      - joint2
    interface_name: position


position_trajectory_controller:
  ros__parameters:
    joints:
      - joint1
      - joint2

    command_interfaces:
      - position

    state_interfaces:
      - position

    state_publish_rate: 200.0 # Defaults to 50
    action_monitor_rate: 20.0 # Defaults to 20

    allow_partial_joints_goal: false # Defaults to false
    open_loop_control: true
    allow_integration_in_goal_trajectories: true
    constraints:
      stopped_velocity_tolerance: 0.01 # Defaults to 0.01
      goal_time: 0.0 # Defaults to 0.0 (start immediately)

//-- 5.1 --//

Dynamixel servos to projects

//-- 5.17 --//

Series of copy past

// -- 5.20 --//

If you don't have a real dynamixel hardware, use in the xacro urdf: <param name="use_dummy">true</param>
Just change to FALSE if your not going to use


NEXT UNITY: TYPE OF CONTROLERS

// -- 6.2 -- //

position_controllers – Controls joints using position commands.
effort_controllers – Controls joints by applying force or torque.
velocity_controllers – Regulates joint movement using velocity commands.
forward_command_controller – Forwards input commands directly to actuators.
joint_trajectory_controller – Executes predefined motion trajectories.
diff_drive_controller – Manages differential drive robots.

//-- 6.5 --//

PASS:

1. ros2 control load_controller --set-state start forward_velocity_controller
2. ros2 control load_controller --set-state start joint_state_broadcaster
3. ros2 topic pub /forward_velocity_controller/commands std_msgs/msg/Float64MultiArray "data:
 - 0.5
 - 0.5" -1





